// OpenNext output (generated by `npm run build:worker`) is the primary Next.js worker.
// This wrapper adds Cloudflare runtime event handlers (e.g. scheduled cron jobs).
//
// Important: keep this file as JS/ESM so `npm run typecheck` does not depend on
// `.open-next/worker.js` being present (it is generated during build).
import openNextWorker from './.open-next/worker.js';
export { BucketCachePurge, DOQueueHandler, DOShardedTagCache } from './.open-next/worker.js';

const CRON_CRAWL_HIGH = '5 * * * *';
const CRON_CRAWL_MEDIUM = '10 */3 * * *';
const CRON_CRAWL_LOW = '15 */6 * * *';
const CRON_EMAIL_PROCESS = '1-59/5 * * * *';

function isEnabled(value) {
  if (value === undefined || value === null) {
    return true;
  }
  const v = String(value).trim().toLowerCase();
  return !(v === '0' || v === 'false' || v === 'off' || v === 'no');
}

async function callInternalJson(path, body, env, ctx) {
  const url = `https://internal${path}`;
  const headers = new Headers({ 'content-type': 'application/json' });

  const cronSecret = env.CRON_SECRET;
  if (typeof cronSecret === 'string' && cronSecret.length > 0) {
    headers.set('x-cron-secret', cronSecret);
  }

  const response = await openNextWorker.fetch(
    new Request(url, { method: 'POST', headers, body: JSON.stringify(body) }),
    env,
    ctx
  );

  if (!response.ok) {
    const text = await response.text().catch(() => '');
    console.error(`[scheduled] internal call failed`, {
      path,
      status: response.status,
      text,
    });
  }
}

export default {
  fetch: openNextWorker.fetch,

  async scheduled(event, env, ctx) {
    const tasks = [];

    // Crawler runs (enabled by default; disable via CRAWLER_ENABLED=false)
    if (isEnabled(env.CRAWLER_ENABLED)) {
      // Avoid running crawls on the email-processing cron.
      if (event.cron !== CRON_EMAIL_PROCESS) {
        const priority =
          event.cron === CRON_CRAWL_HIGH
            ? 'high'
            : event.cron === CRON_CRAWL_MEDIUM
              ? 'medium'
              : event.cron === CRON_CRAWL_LOW
                ? 'low'
                : 'medium';
        tasks.push(callInternalJson('/api/cron/crawl', { priority }, env, ctx));
      }
    }

    // Email queue processing (disabled unless EMAIL_WORKER_ENABLED=true)
    if (event.cron === CRON_EMAIL_PROCESS && isEnabled(env.EMAIL_WORKER_ENABLED)) {
      tasks.push(callInternalJson('/api/cron/email/process', { limit: 25 }, env, ctx));
    }

    for (const task of tasks) {
      ctx.waitUntil(task);
    }
  },
};
