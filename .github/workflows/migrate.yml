# Database Migration Workflow
# Separate workflow for database schema migrations

name: Database Migration

on:
  push:
    branches: [main, develop, staging]
    paths:
      - "web/migrations/**"
      - "web/src/lib/db/schema.sql"
      - "web/src/lib/db/newsletter-schema.sql"
      - "web/src/lib/db/search-schema.sql"
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      migration_file:
        description: "Specific migration file to run (optional)"
        required: false
        type: string
      rollback:
        description: "Rollback the last migration"
        required: false
        default: "false"
        type: boolean

env:
  NODE_VERSION: "20"

jobs:
  # =============================================================================
  # VALIDATE MIGRATIONS
  # =============================================================================
  validate-migrations:
    name: Validate Migration Files
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Validate SQL syntax
        working-directory: ./web
        run: |
          # Check each migration file for valid SQL
          for migration in migrations/*.sql; do
            if [ -f "$migration" ]; then
              echo "Validating $migration"
              # Basic SQL syntax validation
              sqlite3 :memory: < "$migration" 2>&1 | head -20 || echo "Syntax check complete"
            fi
          done

      - name: Check migration naming
        working-directory: ./web
        run: |
          # Validate migration file naming format: YYYYMMDD_HHMMSS_description.sql
          for migration in migrations/*.sql; do
            if [ -f "$migration" ]; then
              filename=$(basename "$migration")
              if [[ ! "$filename" =~ ^[0-9]{8}_[0-9]{6}_.+\.sql$ ]]; then
                echo "Error: Migration $filename does not follow naming format"
                exit 1
              fi
              echo "Migration $filename has valid naming"
            fi
          done

  # =============================================================================
  # PLAN MIGRATIONS
  # =============================================================================
  plan:
    name: Plan Migration
    runs-on: ubuntu-latest
    needs: validate-migrations
    timeout-minutes: 10
    outputs:
      pending_migrations: ${{ steps.migrate-info.outputs.pending }}
      database_name: ${{ steps.migrate-info.outputs.database }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Get migration info
        id: migrate-info
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Determine database name based on environment
          if [ "${{ github.event.inputs.environment }}" = "production" ] || [ "${{ github.ref }}" = "refs/heads/main" ]; then
            DB_NAME="ai_news_db"
          else
            DB_NAME="ai_news_db_staging"
          fi

          echo "database=$DB_NAME" >> $GITHUB_OUTPUT

          # Get applied migrations
          echo "Checking migrations for database: $DB_NAME"

          # Create migrations table if not exists
          wrangler d1 execute $DB_NAME --command="
            CREATE TABLE IF NOT EXISTS _migrations (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL UNIQUE,
              applied_at INTEGER NOT NULL,
              rolled_back_at INTEGER
            );
          " || echo "Migration table check failed (might be first run)"

          # List pending migrations
          echo "Pending migrations will be applied in next step"

      - name: Summary of migrations
        run: |
          echo "### Database Migration Plan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Database:** ${{ steps.migrate-info.outputs.database }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ github.event.inputs.environment || 'auto-detect' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Migration files to be processed:" >> $GITHUB_STEP_SUMMARY
          ls -1 web/migrations/*.sql 2>/dev/null | while read f; do
            echo "- $(basename $f)" >> $GITHUB_STEP_SUMMARY
          done

  # =============================================================================
  # APPLY MIGRATIONS (STAGING)
  # =============================================================================
  migrate-staging:
    name: Apply Migrations (Staging)
    runs-on: ubuntu-latest
    needs: plan
    if: github.event.inputs.environment != 'production' && github.ref != 'refs/heads/main'
    timeout-minutes: 15
    environment:
      name: staging-database

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Run specific migration (if provided)
        if: github.event.inputs.migration_file != ''
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          MIGRATION="migrations/${{ github.event.inputs.migration_file }}"
          if [ -f "$MIGRATION" ]; then
            wrangler d1 execute ai_news_db_staging --file="$MIGRATION"
            echo "Migration $MIGRATION applied successfully"
          else
            echo "Migration file not found: $MIGRATION"
            exit 1
          fi

      - name: Apply all pending migrations
        if: github.event.inputs.migration_file == ''
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Ensure migrations table exists
          wrangler d1 execute ai_news_db_staging --command="
            CREATE TABLE IF NOT EXISTS _migrations (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL UNIQUE,
              applied_at INTEGER NOT NULL,
              rolled_back_at INTEGER
            );
          " || true

          # Apply migrations in order
          for migration in migrations/*.sql; do
            if [ -f "$migration" ]; then
              migration_name=$(basename "$migration")
              echo "Checking migration: $migration_name"

              # Check if already applied
              result=$(wrangler d1 execute ai_news_db_staging --command="SELECT 1 FROM _migrations WHERE name = '$migration_name' AND rolled_back_at IS NULL" --json 2>/dev/null || echo '{"result":[]}')
              applied=$(echo "$result" | jq '.result | length')

              if [ "$applied" -eq 0 ]; then
                echo "Applying: $migration_name"
                wrangler d1 execute ai_news_db_staging --file="$migration"
                wrangler d1 execute ai_news_db_staging --command="INSERT INTO _migrations (name, applied_at) VALUES ('$migration_name', $(date +%s)000)"
                echo "Applied: $migration_name"
              else
                echo "Skipping already applied: $migration_name"
              fi
            fi
          done

      - name: Rollback migration (if requested)
        if: github.event.inputs.rollback == 'true'
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Get the last applied migration
          LAST_MIGRATION=$(wrangler d1 execute ai_news_db_staging --command="SELECT name FROM _migrations WHERE rolled_back_at IS NULL ORDER BY applied_at DESC LIMIT 1" --json | jq -r '.result[0].name')

          if [ -n "$LAST_MIGRATION" ] && [ "$LAST_MIGRATION" != "null" ]; then
            echo "Rolling back: $LAST_MIGRATION"

            # Check for rollback file
            ROLLBACK_FILE="migrations/rollback/$(basename $LAST_MIGRATION .sql).rollback.sql"
            if [ -f "$ROLLBACK_FILE" ]; then
              wrangler d1 execute ai_news_db_staging --file="$ROLLBACK_FILE"
            fi

            # Mark as rolled back
            wrangler d1 execute ai_news_db_staging --command="UPDATE _migrations SET rolled_back_at = $(date +%s)000 WHERE name = '$LAST_MIGRATION'"
            echo "Rolled back: $LAST_MIGRATION"
          else
            echo "No migration to rollback"
          fi

  # =============================================================================
  # APPLY MIGRATIONS (PRODUCTION)
  # =============================================================================
  migrate-production:
    name: Apply Migrations (Production)
    runs-on: ubuntu-latest
    needs: plan
    if: github.event.inputs.environment == 'production' || (github.ref == 'refs/heads/main' && github.event_name == 'push')
    timeout-minutes: 20
    environment:
      name: production-database

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Backup database before migration
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Create a backup timestamp
          BACKUP_TS=$(date +%s)
          echo "Creating backup timestamp: $BACKUP_TS"

          # Store backup info in KV
          wrangler kv key put "db_backup_before_$BACKUP_TS" "{\"timestamp\":$BACKUP_TS,\"commit\":\"${GITHUB_SHA}\"}" --namespace-id=METRICS || true

      - name: Create pre-migration snapshot
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Export schema for backup
          wrangler d1 export ai_news_db --output=backup_schema_${GITHUB_SHA::7}.sql || true

      - name: Run specific migration (if provided)
        if: github.event.inputs.migration_file != ''
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          MIGRATION="migrations/${{ github.event.inputs.migration_file }}"
          if [ -f "$MIGRATION" ]; then
            wrangler d1 execute ai_news_db --file="$MIGRATION"
            echo "Migration $MIGRATION applied successfully to production"
          else
            echo "Migration file not found: $MIGRATION"
            exit 1
          fi

      - name: Apply all pending migrations
        if: github.event.inputs.migration_file == ''
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Ensure migrations table exists
          wrangler d1 execute ai_news_db --command="
            CREATE TABLE IF NOT EXISTS _migrations (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL UNIQUE,
              applied_at INTEGER NOT NULL,
              rolled_back_at INTEGER
            );
          " || true

          # Apply migrations in order
          for migration in migrations/*.sql; do
            if [ -f "$migration" ]; then
              migration_name=$(basename "$migration")
              echo "Checking migration: $migration_name"

              # Check if already applied
              result=$(wrangler d1 execute ai_news_db --command="SELECT 1 FROM _migrations WHERE name = '$migration_name' AND rolled_back_at IS NULL" --json 2>/dev/null || echo '{"result":[]}')
              applied=$(echo "$result" | jq '.result | length')

              if [ "$applied" -eq 0 ]; then
                echo "Applying: $migration_name"
                wrangler d1 execute ai_news_db --file="$migration"
                wrangler d1 execute ai_news_db --command="INSERT INTO _migrations (name, applied_at) VALUES ('$migration_name', $(date +%s)000)"
                echo "Applied: $migration_name"
              else
                echo "Skipping already applied: $migration_name"
              fi
            fi
          done

      - name: Rollback migration (if requested)
        if: github.event.inputs.rollback == 'true'
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Get the last applied migration
          LAST_MIGRATION=$(wrangler d1 execute ai_news_db --command="SELECT name FROM _migrations WHERE rolled_back_at IS NULL ORDER BY applied_at DESC LIMIT 1" --json | jq -r '.result[0].name')

          if [ -n "$LAST_MIGRATION" ] && [ "$LAST_MIGRATION" != "null" ]; then
            echo "Rolling back: $LAST_MIGRATION"

            # Check for rollback file
            ROLLBACK_FILE="migrations/rollback/$(basename $LAST_MIGRATION .sql).rollback.sql"
            if [ -f "$ROLLBACK_FILE" ]; then
              wrangler d1 execute ai_news_db --file="$ROLLBACK_FILE"
            fi

            # Mark as rolled back
            wrangler d1 execute ai_news_db --command="UPDATE _migrations SET rolled_back_at = $(date +%s)000 WHERE name = '$LAST_MIGRATION'"
            echo "Rolled back: $LAST_MIGRATION"
          else
            echo "No migration to rollback"
          fi

      - name: Verify migration success
        working-directory: ./web
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Run basic queries to verify database integrity
          wrangler d1 execute ai_news_db --command="SELECT COUNT(*) as count FROM news" | grep -q "count"
          wrangler d1 execute ai_news_db --command "SELECT COUNT(*) as count FROM sources" | grep -q "count"
          echo "Database verification passed"

      - name: Notify migration completion
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "action": "migration",
              "environment": "production",
              "status": "${{ job.status }}",
              "commit": "${{ github.sha }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
